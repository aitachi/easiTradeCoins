# EasiTradeCoins é¡¹ç›®ç¼ºé™·åˆ†æä¸æ”¹è¿›å»ºè®®

> **æ–‡æ¡£ä½œè€…**: Aitachi
> **è”ç³»é‚®ç®±**: 44158892@qq.com
> **åˆ›å»ºæ—¥æœŸ**: 2025-11-02
> **é€‚ç”¨è¯»è€…**: é¡¹ç›®è´Ÿè´£äººã€æ¶æ„å¸ˆã€å¼€å‘å›¢é˜Ÿ
> **é‡è¦ç¨‹åº¦**: â­â­â­â­â­ (å¿…è¯»)

---

## ğŸ“‹ ç›®å½•

1. [æ™ºèƒ½åˆçº¦å±‚ç¼ºé™·](#1-æ™ºèƒ½åˆçº¦å±‚ç¼ºé™·)
2. [Goåç«¯ç¼ºé™·](#2-goåç«¯ç¼ºé™·)
3. [æ¶æ„è®¾è®¡ç¼ºé™·](#3-æ¶æ„è®¾è®¡ç¼ºé™·)
4. [å®‰å…¨éšæ‚£](#4-å®‰å…¨éšæ‚£)
5. [æ€§èƒ½ç“¶é¢ˆ](#5-æ€§èƒ½ç“¶é¢ˆ)
6. [æ”¹è¿›ä¼˜å…ˆçº§ä¸è·¯çº¿å›¾](#6-æ”¹è¿›ä¼˜å…ˆçº§ä¸è·¯çº¿å›¾)

---

## 1. æ™ºèƒ½åˆçº¦å±‚ç¼ºé™·

### 1.1 ã€ä¸¥é‡ã€‘ç¼ºå°‘æš‚åœæœºåˆ¶

**ä½ç½®:** `contracts/src/DEXAggregator.sol`, `contracts/src/LiquidityMining.sol`

**é—®é¢˜æè¿°:**

```solidity
// âŒ å½“å‰è®¾è®¡: æ— æ³•ç´§æ€¥æš‚åœåˆçº¦
contract DEXAggregator is Ownable, ReentrancyGuard {
    // å¦‚æœå‘ç°æ¼æ´, æ— æ³•ç«‹å³åœæ­¢ç”¨æˆ·äº¤æ˜“
    function swapWithBestPrice(...) external nonReentrant {
        // ...
    }
}
```

**é£é™©ç­‰çº§:** ğŸ”´ **ä¸¥é‡** (Critical)

**å½±å“èŒƒå›´:**
- å‘ç°æ¼æ´æ—¶æ— æ³•ç«‹å³æ­¢æŸ
- æ— æ³•åº”å¯¹ç´§æ€¥æƒ…å†µ (å¦‚é¢„è¨€æœºæ”»å‡»ã€é—ªç”µè´·æ”»å‡»)
- å¯èƒ½å¯¼è‡´å¤§é‡èµ„é‡‘æŸå¤±

**æ”¹è¿›æ–¹æ¡ˆ:**

```solidity
import "@openzeppelin/contracts/security/Pausable.sol";

contract DEXAggregator is Ownable, ReentrancyGuard, Pausable {

    // æ·»åŠ  whenNotPaused ä¿®é¥°ç¬¦
    function swapWithBestPrice(...) external nonReentrant whenNotPaused {
        // ...
    }

    function swapMultiHop(...) external nonReentrant whenNotPaused {
        // ...
    }

    // ç´§æ€¥æš‚åœå‡½æ•°
    function pause() external onlyOwner {
        _pause();
        emit EmergencyPause(msg.sender, block.timestamp);
    }

    // æ¢å¤è¿è¡Œ
    function unpause() external onlyOwner {
        _unpause();
        emit EmergencyUnpause(msg.sender, block.timestamp);
    }
}
```

**å®æ–½æˆæœ¬:** ä½ (1-2å°æ—¶)
**ä¼˜å…ˆçº§:** P0 (ç«‹å³ä¿®å¤)

---

### 1.2 ã€é«˜ã€‘DEXç™½åå•ç¼ºä¹éªŒè¯

**ä½ç½®:** `contracts/src/DEXAggregator.sol:50-58`

**é—®é¢˜ä»£ç :**

```solidity
function addDEX(address _dexRouter) external onlyOwner {
    require(_dexRouter != address(0), "Invalid DEX address");
    // âŒ æœªéªŒè¯åœ°å€æ˜¯å¦çœŸçš„æ˜¯DEX Router
    // âŒ æœªæ£€æŸ¥æ¥å£å®ç°
    // âŒ æ¶æ„åœ°å€å¯èƒ½è¢«æ·»åŠ 
    dexRouters.push(_dexRouter);
    isDexSupported[_dexRouter] = true;
    emit DEXAdded(_dexRouter);
}
```

**é£é™©ç­‰çº§:** ğŸŸ  **é«˜** (High)

**æ”»å‡»åœºæ™¯:**

1. Ownerç§é’¥æ³„éœ²
2. æ”»å‡»è€…æ·»åŠ æ¶æ„åˆçº¦åœ°å€åˆ° `dexRouters`
3. ç”¨æˆ·è°ƒç”¨ `swapWithBestPrice` æ—¶,èµ„é‡‘è¢«è½¬ç§»åˆ°æ¶æ„åˆçº¦

**æ”¹è¿›æ–¹æ¡ˆ:**

```solidity
function addDEX(address _dexRouter) external onlyOwner {
    require(_dexRouter != address(0), "Invalid DEX address");

    // âœ… éªŒè¯åˆçº¦å®ç°äº†IUniswapV2Routeræ¥å£
    try IUniswapV2Router(_dexRouter).factory() returns (address factory) {
        require(factory != address(0), "Invalid factory");
    } catch {
        revert("Not a valid Uniswap V2 Router");
    }

    // âœ… æ£€æŸ¥é‡å¤æ·»åŠ 
    require(!isDexSupported[_dexRouter], "DEX already added");

    dexRouters.push(_dexRouter);
    isDexSupported[_dexRouter] = true;

    emit DEXAdded(_dexRouter);
}
```

**å®æ–½æˆæœ¬:** ä½ (1å°æ—¶)
**ä¼˜å…ˆçº§:** P1 (é«˜ä¼˜å…ˆçº§)

---

### 1.3 ã€é«˜ã€‘ç¼ºå°‘ä»·æ ¼é¢„è¨€æœºä¿æŠ¤

**ä½ç½®:** `contracts/src/DEXAggregator.sol`

**é—®é¢˜æè¿°:**

```solidity
// âŒ å®Œå…¨ä¾èµ–DEXå³æ—¶æŠ¥ä»·
function getBestQuote(...) public view returns (Quote memory) {
    // æ˜“å—é—ªç”µè´·ä»·æ ¼æ“çºµæ”»å‡»
    // æ— TWAP (æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼) ä¿æŠ¤
    for (uint256 i = 0; i < dexRouters.length; i++) {
        uint256 amountOut = router.getAmountsOut(amountIn, path);
        // ...
    }
}
```

**é£é™©ç­‰çº§:** ğŸŸ  **é«˜** (High)

**æ”»å‡»åœºæ™¯:**

```
1. æ”»å‡»è€…é€šè¿‡é—ªç”µè´·å€Ÿå…¥å¤§é‡ä»£å¸
2. åœ¨ç›®æ ‡DEXä¸Šåˆ¶é€ å·¨å¤§æ»‘ç‚¹, æ“çºµä»·æ ¼
3. ç«‹å³è°ƒç”¨ swapWithBestPrice
4. ä»¥æ“çºµåçš„ä¸åˆ©ä»·æ ¼æˆäº¤
5. å½’è¿˜é—ªç”µè´·, å¥—åˆ©ç¦»åœº
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```solidity
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract DEXAggregator is Ownable, ReentrancyGuard {
    // Chainlinkä»·æ ¼é¢„è¨€æœº
    mapping(address => AggregatorV3Interface) public priceFeeds;

    // æœ€å¤§ä»·æ ¼åç¦»é˜ˆå€¼ (5%)
    uint256 public constant MAX_PRICE_DEVIATION = 500; // 5.00%

    function swapWithBestPrice(...) external nonReentrant {
        Quote memory quote = getBestQuote(tokenIn, tokenOut, amountIn);

        // âœ… éªŒè¯DEXä»·æ ¼ä¸é¢„è¨€æœºä»·æ ¼çš„åç¦»
        validatePriceDeviation(tokenIn, tokenOut, quote.amountOut, amountIn);

        // ... æ‰§è¡Œäº¤æ¢
    }

    function validatePriceDeviation(
        address tokenIn,
        address tokenOut,
        uint256 dexAmountOut,
        uint256 amountIn
    ) internal view {
        uint256 oraclePrice = getChainlinkPrice(tokenIn, tokenOut);
        uint256 dexPrice = dexAmountOut.mul(1e18).div(amountIn);

        uint256 deviation = dexPrice > oraclePrice
            ? (dexPrice - oraclePrice).mul(10000).div(oraclePrice)
            : (oraclePrice - dexPrice).mul(10000).div(oraclePrice);

        require(deviation <= MAX_PRICE_DEVIATION, "Price deviates >5% from oracle");
    }
}
```

**å®æ–½æˆæœ¬:** ä¸­ (4-6å°æ—¶)
**ä¼˜å…ˆçº§:** P1 (é«˜ä¼˜å…ˆçº§)

---

### 1.4 ã€ä¸­ã€‘LiquidityMining ç¼ºå°‘å¥–åŠ±ä¸Šé™

**ä½ç½®:** `contracts/src/LiquidityMining.sol:109-114`

**é—®é¢˜ä»£ç :**

```solidity
function setRewardPerBlock(uint256 _rewardPerBlock, bool _withUpdate) external onlyOwner {
    if (_withUpdate) {
        massUpdatePools();
    }
    // âŒ æ— ä¸Šé™æ£€æŸ¥, Ownerå¯è®¾ç½®å¤©ä»·å¥–åŠ±
    rewardPerBlock = _rewardPerBlock;
}
```

**é£é™©ç­‰çº§:** ğŸŸ¡ **ä¸­** (Medium)

**é£é™©:**
- Ownerå¤±è¯¯è®¾ç½®è¿‡é«˜å¥–åŠ±
- åˆçº¦å¥–åŠ±ä»£å¸å¿«é€Ÿè€—å°½
- ç”¨æˆ·æ— æ³•é¢†å–å¥–åŠ±

**æ”¹è¿›æ–¹æ¡ˆ:**

```solidity
uint256 public constant MAX_REWARD_PER_BLOCK = 100e18; // æ¯åŒºå—æœ€å¤š100ä»£å¸

function setRewardPerBlock(uint256 _rewardPerBlock, bool _withUpdate) external onlyOwner {
    require(_rewardPerBlock <= MAX_REWARD_PER_BLOCK, "Exceeds max reward");

    if (_withUpdate) {
        massUpdatePools();
    }

    rewardPerBlock = _rewardPerBlock;
    emit RewardPerBlockUpdated(_rewardPerBlock);
}
```

**å®æ–½æˆæœ¬:** æä½ (30åˆ†é’Ÿ)
**ä¼˜å…ˆçº§:** P2 (ä¸­ä¼˜å…ˆçº§)

---

### 1.5 ã€ä¸­ã€‘ç¼ºå°‘å¤šç­¾é’±åŒ…ä¿æŠ¤

**é—®é¢˜æè¿°:**

```
å½“å‰Owneræƒé™:
â”œâ”€â”€ å•ä¸€åœ°å€æ§åˆ¶ (EOAè´¦æˆ·)
â”œâ”€â”€ ç§é’¥æ³„éœ² â†’ åˆçº¦å®Œå…¨è¢«æ§åˆ¶
â””â”€â”€ æ— æ³•æ’¤é”€çš„æ“ä½œ (addDEX, updateFee, etc.)
```

**é£é™©ç­‰çº§:** ğŸŸ¡ **ä¸­** (Medium)

**æ”¹è¿›æ–¹æ¡ˆ:**

```solidity
// ä½¿ç”¨ Gnosis Safe å¤šç­¾é’±åŒ…

// éƒ¨ç½²æ—¶è®¾ç½®å¤šç­¾åœ°å€ä¸ºOwner
const gnosisSafe = "0x..."; // 3/5 å¤šç­¾é’±åŒ…
const dexAggregator = await DEXAggregator.deploy(gnosisSafe);

// å…³é”®æ“ä½œéœ€è¦å¤šä¸ªç­¾åç¡®è®¤:
// - addDEX
// - updatePlatformFee
// - pause/unpause
// - è½¬ç§»æ‰€æœ‰æƒ
```

**å®æ–½æˆæœ¬:** ä½ (é›†æˆç°æœ‰å·¥å…·)
**ä¼˜å…ˆçº§:** P2 (ä¸­ä¼˜å…ˆçº§)

---

## 2. Goåç«¯ç¼ºé™·

### 2.1 ã€ä¸¥é‡ã€‘è®¢å•ç°¿æ€§èƒ½ç“¶é¢ˆ

**ä½ç½®:** `go-backend/internal/matching/orderbook.go:107-127`

**é—®é¢˜ä»£ç :**

```go
// âŒ O(n) æ—¶é—´å¤æ‚åº¦è·å–æœ€ä¼˜ä»·æ ¼
func (ob *OrderBook) GetBestBid() (decimal.Decimal, bool) {
    ob.mu.RLock()
    defer ob.mu.RUnlock()

    if len(ob.BuyLevels) == 0 {
        return decimal.Zero, false
    }

    var bestPrice decimal.Decimal
    first := true

    // éå†æ‰€æœ‰ä»·æ ¼çº§åˆ« - æ€§èƒ½å·®!
    for priceStr := range ob.BuyLevels {
        price, _ := decimal.NewFromString(priceStr)
        if first || price.GreaterThan(bestPrice) {
            bestPrice = price
            first = false
        }
    }

    return bestPrice, true
}
```

**æ€§èƒ½å½±å“:**

| ä»·æ ¼çº§åˆ«æ•° | æŸ¥è¯¢å»¶è¿Ÿ |
|----------|---------|
| 10 | ~100Î¼s |
| 100 | ~1ms |
| 1,000 | ~10ms |
| 10,000 | ~100ms âš ï¸ |

**é£é™©ç­‰çº§:** ğŸ”´ **ä¸¥é‡** (Critical)

**æ”¹è¿›æ–¹æ¡ˆ 1: ä½¿ç”¨å † (Heap)**

```go
import "container/heap"

type OrderBook struct {
    Symbol     string
    BuyLevels  map[string]*PriceLevel
    SellLevels map[string]*PriceLevel
    OrderMap   map[string]*models.Order

    // âœ… æ·»åŠ æœ€å¤§å †/æœ€å°å †
    bestBidHeap *MaxHeap  // ä¹°å•æœ€å¤§å †
    bestAskHeap *MinHeap  // å–å•æœ€å°å †

    mu         sync.RWMutex
}

// O(1) æŸ¥è¯¢æœ€ä¼˜ä»·æ ¼
func (ob *OrderBook) GetBestBid() (decimal.Decimal, bool) {
    ob.mu.RLock()
    defer ob.mu.RUnlock()

    if ob.bestBidHeap.Len() == 0 {
        return decimal.Zero, false
    }

    return ob.bestBidHeap.Peek(), true
}

// O(log n) æ’å…¥æ–°ä»·æ ¼çº§åˆ«
func (ob *OrderBook) AddOrder(order *models.Order) {
    ob.mu.Lock()
    defer ob.mu.Unlock()

    // ...
    if order.Side == models.OrderSideBuy {
        heap.Push(ob.bestBidHeap, order.Price)
    } else {
        heap.Push(ob.bestAskHeap, order.Price)
    }
}
```

**æ”¹è¿›æ–¹æ¡ˆ 2: ä½¿ç”¨çº¢é»‘æ ‘**

```go
import "github.com/emirpasic/gods/trees/redblacktree"

type OrderBook struct {
    // âœ… ä½¿ç”¨çº¢é»‘æ ‘ç»´æŠ¤æœ‰åºä»·æ ¼
    buyTree  *redblacktree.Tree  // é™åº
    sellTree *redblacktree.Tree  // å‡åº
    // ...
}

// O(1) æŸ¥è¯¢
func (ob *OrderBook) GetBestBid() (decimal.Decimal, bool) {
    max := ob.buyTree.Right()  // æœ€å¤§å€¼
    if max == nil {
        return decimal.Zero, false
    }
    return max.Key.(decimal.Decimal), true
}
```

**æ€§èƒ½å¯¹æ¯”:**

| æ“ä½œ | å½“å‰å®ç° | å †å®ç° | çº¢é»‘æ ‘ |
|------|---------|-------|-------|
| æŸ¥è¯¢æœ€ä¼˜ä»· | O(n) | O(1) | O(1) |
| æ’å…¥è®¢å• | O(1) | O(log n) | O(log n) |
| åˆ é™¤è®¢å• | O(1) | O(log n) | O(log n) |

**å®æ–½æˆæœ¬:** ä¸­ (8-12å°æ—¶)
**ä¼˜å…ˆçº§:** P0 (ç«‹å³ä¿®å¤)

---

### 2.2 ã€é«˜ã€‘ç¼ºå°‘æ’®åˆå¼•æ“äº‹åŠ¡ä¿è¯

**ä½ç½®:** `go-backend/internal/matching/engine.go`

**é—®é¢˜æè¿°:**

```go
// âŒ æ’®åˆæˆåŠŸå,æ²¡æœ‰åŸå­æ›´æ–°æ•°æ®åº“
func (me *MatchingEngine) ProcessOrder(order *models.Order) ([]*models.Trade, error) {
    trades := me.matchLimitOrder(ob, order)

    // å¦‚æœè¿™é‡Œç¨‹åºå´©æºƒ:
    // - å†…å­˜è®¢å•ç°¿å·²æ›´æ–°
    // - æ•°æ®åº“æœªæ›´æ–°
    // â†’ æ•°æ®ä¸ä¸€è‡´!

    // å‘é€åˆ°trade channel
    for _, trade := range trades {
        me.tradeChan <- trade
    }

    return trades, nil
}
```

**é£é™©ç­‰çº§:** ğŸŸ  **é«˜** (High)

**æ•°æ®ä¸€è‡´æ€§é—®é¢˜:**

```
åœºæ™¯: ç”¨æˆ·ä¸‹ä¹°å• 100 BTC @ 50,000 USDT
1. æ’®åˆå¼•æ“æˆäº¤ â†’ å†…å­˜è®¢å•ç°¿æ›´æ–°
2. ç¨‹åºå´©æºƒ (å®•æœº/é‡å¯)
3. é‡å¯åä»æ•°æ®åº“æ¢å¤ â†’ è®¢å•è¿˜åœ¨!
4. ç”¨æˆ·é‡å¤æˆäº¤ â†’ èµ„é‡‘æŸå¤±
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
import "gorm.io/gorm"

func (me *MatchingEngine) ProcessOrder(order *models.Order) ([]*models.Trade, error) {
    // âœ… ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
    return me.db.Transaction(func(tx *gorm.DB) error {
        // [1] æ’®åˆ
        trades := me.matchLimitOrder(ob, order)

        // [2] åŸå­æ›´æ–°æ•°æ®åº“
        for _, trade := range trades {
            if err := tx.Create(trade).Error; err != nil {
                return err  // å›æ»š
            }
        }

        // [3] æ›´æ–°è®¢å•çŠ¶æ€
        if err := tx.Save(order).Error; err != nil {
            return err
        }

        // [4] æ›´æ–°ç”¨æˆ·èµ„äº§
        if err := me.updateUserAssets(tx, trades); err != nil {
            return err
        }

        // [5] å‘é€äº‹ä»¶ (äº‹åŠ¡æäº¤å)
        for _, trade := range trades {
            me.tradeChan <- trade
        }

        return nil  // æäº¤äº‹åŠ¡
    })
}
```

**å®æ–½æˆæœ¬:** ä¸­ (6-10å°æ—¶)
**ä¼˜å…ˆçº§:** P1 (é«˜ä¼˜å…ˆçº§)

---

### 2.3 ã€é«˜ã€‘æ æ†äº¤æ˜“ç¼ºå°‘èµ„äº§é”å®š

**ä½ç½®:** `go-backend/internal/services/margin_trading_service.go`

**é—®é¢˜æè¿°:**

```go
// âŒ å¼€ä»“æ—¶æ²¡æœ‰é”å®šä¿è¯é‡‘
func (s *MarginTradingService) OpenPosition(...) (*MarginPosition, error) {
    // æ£€æŸ¥è´¦æˆ·ä½™é¢
    if requiredMargin.GreaterThan(availableMargin) {
        return nil, errors.New("insufficient margin")
    }

    // åˆ›å»ºæŒä»“
    position := &MarginPosition{
        Margin: requiredMargin,
        // ...
    }
    s.db.Create(position)

    // âš ï¸ ä¿è¯é‡‘æ²¡æœ‰ä»è´¦æˆ·æ‰£é™¤!
    // ç”¨æˆ·å¯ä»¥å¤šæ¬¡å¼€ä»“ä½¿ç”¨åŒä¸€ç¬”ä¿è¯é‡‘
}
```

**é£é™©ç­‰çº§:** ğŸŸ  **é«˜** (High)

**æ”»å‡»åœºæ™¯:**

```
1. ç”¨æˆ·è´¦æˆ·ä½™é¢: 1,000 USDT
2. å¼€10å€æ æ†, æŒä»“ä»·å€¼10,000 USDT (éœ€è¦1,000ä¿è¯é‡‘)
3. å†æ¬¡å¼€ä»“10,000 USDT â†’ æˆåŠŸ! (ä¿è¯é‡‘æœªé”å®š)
4. é‡å¤å¼€ä»“ â†’ æ— é™æ æ†!
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
func (s *MarginTradingService) OpenPosition(...) (*MarginPosition, error) {
    return s.db.Transaction(func(tx *gorm.DB) error {
        account, err := s.GetOrCreateMarginAccount(ctx, userID)
        if err != nil {
            return err
        }

        // [1] è®¡ç®—æ‰€éœ€ä¿è¯é‡‘
        positionValue := price.Mul(quantity)
        requiredMargin := positionValue.Div(decimal.NewFromInt(int64(leverage)))

        // [2] æ£€æŸ¥å¯ç”¨ä½™é¢
        availableMargin := account.Equity
        if requiredMargin.GreaterThan(availableMargin) {
            return errors.New("insufficient margin")
        }

        // [3] âœ… é”å®šä¿è¯é‡‘ (ä»equityæ‰£é™¤)
        account.LockedMargin = account.LockedMargin.Add(requiredMargin)
        account.Equity = account.Equity.Sub(requiredMargin)

        if err := tx.Save(account).Error; err != nil {
            return err
        }

        // [4] åˆ›å»ºæŒä»“
        position := &MarginPosition{
            Margin: requiredMargin,
            // ...
        }

        return tx.Create(position).Error
    })
}

// å¹³ä»“æ—¶é‡Šæ”¾ä¿è¯é‡‘
func (s *MarginTradingService) ClosePosition(...) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // ...

        // âœ… é‡Šæ”¾ä¿è¯é‡‘
        account.LockedMargin = account.LockedMargin.Sub(position.Margin)
        account.Equity = account.Equity.Add(position.Margin).Add(position.RealizedPnL)

        return tx.Save(account).Error
    })
}
```

**å®æ–½æˆæœ¬:** ä¸­ (4-6å°æ—¶)
**ä¼˜å…ˆçº§:** P0 (ç«‹å³ä¿®å¤)

---

### 2.4 ã€ä¸­ã€‘ç½‘æ ¼äº¤æ˜“ç­–ç•¥ç¼ºå°‘å¹¶å‘ä¿æŠ¤

**ä½ç½®:** `go-backend/internal/services/grid_trading_service.go:336-372`

**é—®é¢˜ä»£ç :**

```go
func (s *GridTradingService) updateGridStrategy(ctx context.Context, strategyID string) bool {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    // ...
    for i := range levels {
        level := &levels[i]
        s.checkGridLevel(ctx, &strategy, level)
    }
    // ...
}

func (s *GridTradingService) checkGridLevel(...) {
    // âš ï¸ è°ƒç”¨ orderService.CreateOrder (å¯èƒ½è€—æ—¶)
    // âš ï¸ æŒæœ‰é”æœŸé—´è¿›è¡ŒI/Oæ“ä½œ â†’ æ€§èƒ½ä¸‹é™
    s.createBuyOrder(ctx, strategy, level)
}
```

**é£é™©ç­‰çº§:** ğŸŸ¡ **ä¸­** (Medium)

**æ€§èƒ½å½±å“:**

```
é”æŒæœ‰æ—¶é—´ = éå†æ‰€æœ‰ç½‘æ ¼ Ã— æ¯æ¬¡æ•°æ®åº“æ“ä½œæ—¶é—´
             = 100ç½‘æ ¼ Ã— 10ms = 1ç§’

â†’ å…¶ä»–goroutineè¢«é˜»å¡1ç§’!
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
func (s *GridTradingService) updateGridStrategy(...) bool {
    // [1] å¿«é€Ÿè¯»å–æ•°æ® (æŒé”æ—¶é—´çŸ­)
    s.mutex.RLock()
    var strategy GridStrategy
    s.db.First(&strategy, "id = ?", strategyID)

    var levels []GridLevel
    s.db.Where("strategy_id = ?", strategyID).Find(&levels)
    s.mutex.RUnlock()

    // [2] âœ… æ— é”å¤„ç† (å¹¶å‘æ‰§è¡Œ)
    var wg sync.WaitGroup
    for i := range levels {
        wg.Add(1)
        go func(level *GridLevel) {
            defer wg.Done()
            s.checkGridLevel(ctx, &strategy, level)
        }(&levels[i])
    }
    wg.Wait()

    // [3] æ‰¹é‡æ›´æ–° (æŒé”æ—¶é—´çŸ­)
    s.mutex.Lock()
    s.db.Save(&strategy)
    s.db.Save(&levels)
    s.mutex.Unlock()

    return false
}
```

**å®æ–½æˆæœ¬:** ä½ (2-3å°æ—¶)
**ä¼˜å…ˆçº§:** P2 (ä¸­ä¼˜å…ˆçº§)

---

## 3. æ¶æ„è®¾è®¡ç¼ºé™·

### 3.1 ã€é«˜ã€‘ç¼ºå°‘æœåŠ¡é™çº§æœºåˆ¶

**é—®é¢˜æè¿°:**

```
å½“å‰æ¶æ„:
â”œâ”€â”€ æ‰€æœ‰æœåŠ¡å¼ºä¾èµ–æ•°æ®åº“
â”œâ”€â”€ æ•°æ®åº“æ•…éšœ â†’ æ•´ä¸ªç³»ç»Ÿä¸å¯ç”¨
â””â”€â”€ æ— ç†”æ–­å™¨ (Circuit Breaker)

é›ªå´©æ•ˆåº”:
æ•°æ®åº“æ…¢ â†’ è¯·æ±‚å †ç§¯ â†’ å†…å­˜æº¢å‡º â†’ æœåŠ¡å´©æºƒ
```

**é£é™©ç­‰çº§:** ğŸŸ  **é«˜** (High)

**æ”¹è¿›æ–¹æ¡ˆ: é›†æˆç†”æ–­å™¨**

```go
import "github.com/sony/gobreaker"

type OrderService struct {
    db      *gorm.DB
    breaker *gobreaker.CircuitBreaker
}

func NewOrderService(...) *OrderService {
    // âœ… é…ç½®ç†”æ–­å™¨
    breaker := gobreaker.NewCircuitBreaker(gobreaker.Settings{
        Name:        "OrderService",
        MaxRequests: 3,
        Interval:    time.Second * 10,
        Timeout:     time.Second * 60,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    })

    return &OrderService{
        db:      db,
        breaker: breaker,
    }
}

func (s *OrderService) CreateOrder(order *models.Order) (*models.Order, []*models.Trade, error) {
    // âœ… ä½¿ç”¨ç†”æ–­å™¨
    result, err := s.breaker.Execute(func() (interface{}, error) {
        return s.createOrderInternal(order)
    })

    if err == gobreaker.ErrOpenState {
        // ç†”æ–­å™¨æ‰“å¼€ â†’ å¿«é€Ÿå¤±è´¥
        return nil, nil, errors.New("service temporarily unavailable")
    }

    return result.(*models.Order), nil, err
}
```

**å®æ–½æˆæœ¬:** ä¸­ (6-8å°æ—¶)
**ä¼˜å…ˆçº§:** P1 (é«˜ä¼˜å…ˆçº§)

---

### 3.2 ã€ä¸­ã€‘ç¼ºå°‘åˆ†å¸ƒå¼é“¾è·¯è¿½è¸ª

**é—®é¢˜æè¿°:**

```
å½“å‰é—®é¢˜:
â”œâ”€â”€ æ— æ³•è¿½è¸ªè¯·æ±‚åœ¨å¾®æœåŠ¡é—´çš„æµè½¬
â”œâ”€â”€ æ€§èƒ½ç“¶é¢ˆéš¾ä»¥å®šä½
â””â”€â”€ é”™è¯¯è¿½è¸ªå›°éš¾
```

**æ”¹è¿›æ–¹æ¡ˆ: é›†æˆ OpenTelemetry**

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func (s *OrderService) CreateOrder(...) (*models.Order, []*models.Trade, error) {
    ctx, span := otel.Tracer("order-service").Start(ctx, "CreateOrder")
    defer span.End()

    // è®°å½•å…³é”®ä¿¡æ¯
    span.SetAttributes(
        attribute.String("user_id", order.UserID),
        attribute.String("symbol", order.Symbol),
        attribute.String("side", order.Side),
    )

    // è°ƒç”¨å…¶ä»–æœåŠ¡æ—¶ä¼ é€’trace context
    trades, err := s.matchingEngine.ProcessOrder(ctx, order)
    if err != nil {
        span.RecordError(err)
        return nil, nil, err
    }

    return order, trades, nil
}
```

**å®æ–½æˆæœ¬:** ä¸­ (8-10å°æ—¶)
**ä¼˜å…ˆçº§:** P2 (ä¸­ä¼˜å…ˆçº§)

---

### 3.3 ã€ä¸­ã€‘ç¼ºå°‘æ¶ˆæ¯é˜Ÿåˆ—å¯é æ€§ä¿è¯

**ä½ç½®:** `go-backend/cmd/server/main.go:180-192`

**é—®é¢˜ä»£ç :**

```go
func processTrades(engine *matching.MatchingEngine, hub *websocket.Hub) {
    tradeChan := engine.GetTradeChan()

    for trade := range tradeChan {
        // âŒ å¦‚æœ BroadcastTrade å¤±è´¥, æ¶ˆæ¯ä¸¢å¤±
        hub.BroadcastTrade(trade)

        // âŒ æ²¡æœ‰æŒä¹…åŒ–åˆ°Kafka
    }
}
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
import "github.com/segmentio/kafka-go"

func processTrades(engine *matching.MatchingEngine, hub *websocket.Hub, kafkaWriter *kafka.Writer) {
    tradeChan := engine.GetTradeChan()

    for trade := range tradeChan {
        // [1] âœ… å…ˆæŒä¹…åŒ–åˆ°Kafka (å¯é æ€§ä¿è¯)
        tradeJSON, _ := json.Marshal(trade)
        err := kafkaWriter.WriteMessages(context.Background(),
            kafka.Message{
                Key:   []byte(trade.Symbol),
                Value: tradeJSON,
            },
        )

        if err != nil {
            log.Printf("Failed to write to Kafka: %v", err)
            // TODO: é‡è¯•æˆ–å†™å…¥æ­»ä¿¡é˜Ÿåˆ—
        }

        // [2] éé˜»å¡å¹¿æ’­åˆ°WebSocket
        go hub.BroadcastTrade(trade)
    }
}
```

**å®æ–½æˆæœ¬:** ä¸­ (4-6å°æ—¶)
**ä¼˜å…ˆçº§:** P2 (ä¸­ä¼˜å…ˆçº§)

---

## 4. å®‰å…¨éšæ‚£

### 4.1 ã€ä¸¥é‡ã€‘JWTå¯†é’¥ç¡¬ç¼–ç 

**ä½ç½®:** `go-backend/cmd/server/main.go:127`

**é—®é¢˜ä»£ç :**

```go
// âŒ JWTå¯†é’¥ä»é…ç½®æ–‡ä»¶è¯»å– (å¯èƒ½æ³„éœ²)
authMiddleware := middleware.AuthMiddleware(viper.GetString("JWT_SECRET"))
```

**é£é™©ç­‰çº§:** ğŸ”´ **ä¸¥é‡** (Critical)

**é£é™©:**

```
.envæ–‡ä»¶å†…å®¹:
JWT_SECRET=my_super_secret_key_12345

å¦‚æœ .env æ–‡ä»¶è¢«æäº¤åˆ°Git:
â†’ å¯†é’¥æ³„éœ²
â†’ æ”»å‡»è€…å¯ä¼ªé€ JWT token
â†’ æ— é™åˆ¶è®¿é—®API
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```bash
# ä½¿ç”¨ç¯å¢ƒå˜é‡ç®¡ç†å™¨ (å¦‚ AWS Secrets Manager, HashiCorp Vault)

# 1. æœ¬åœ°å¼€å‘: ä½¿ç”¨ dotenv (ä½† .env åŠ å…¥ .gitignore)
echo ".env" >> .gitignore

# 2. ç”Ÿäº§ç¯å¢ƒ: ä½¿ç”¨å¯†é’¥ç®¡ç†æœåŠ¡
export JWT_SECRET=$(aws secretsmanager get-secret-value --secret-id prod/jwt-secret --query SecretString --output text)
```

```go
// âœ… å¼ºåˆ¶ä½¿ç”¨ç¯å¢ƒå˜é‡
func main() {
    jwtSecret := os.Getenv("JWT_SECRET")
    if jwtSecret == "" {
        log.Fatal("JWT_SECRET environment variable is required")
    }

    // éªŒè¯å¯†é’¥é•¿åº¦
    if len(jwtSecret) < 32 {
        log.Fatal("JWT_SECRET must be at least 32 characters")
    }

    authMiddleware := middleware.AuthMiddleware(jwtSecret)
    // ...
}
```

**å®æ–½æˆæœ¬:** ä½ (1-2å°æ—¶)
**ä¼˜å…ˆçº§:** P0 (ç«‹å³ä¿®å¤)

---

### 4.2 ã€é«˜ã€‘SQLæ³¨å…¥é£é™©

**ä½ç½®:** å¤šä¸ªæœåŠ¡æ–‡ä»¶

**é—®é¢˜ç¤ºä¾‹:**

```go
// âš ï¸ æ½œåœ¨é£é™©: å­—ç¬¦ä¸²æ‹¼æ¥SQL
symbol := c.Query("symbol")  // ç”¨æˆ·è¾“å…¥

// âŒ ä¸å®‰å…¨
query := fmt.Sprintf("SELECT * FROM orders WHERE symbol = '%s'", symbol)
db.Raw(query).Scan(&orders)

// æ”»å‡»ç¤ºä¾‹:
// symbol = "BTC' OR '1'='1"
// â†’ SELECT * FROM orders WHERE symbol = 'BTC' OR '1'='1'
// â†’ è¿”å›æ‰€æœ‰è®¢å•!
```

**é£é™©ç­‰çº§:** ğŸŸ  **é«˜** (High)

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
// âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢ (GORMå·²é˜²æŠ¤)
symbol := c.Query("symbol")
db.Where("symbol = ?", symbol).Find(&orders)

// âœ… è¾“å…¥éªŒè¯
func validateSymbol(symbol string) error {
    matched, _ := regexp.MatchString(`^[A-Z]{3,10}/[A-Z]{3,10}$`, symbol)
    if !matched {
        return errors.New("invalid symbol format")
    }
    return nil
}
```

**å®æ–½æˆæœ¬:** ä½ (2-3å°æ—¶å®¡æŸ¥)
**ä¼˜å…ˆçº§:** P1 (é«˜ä¼˜å…ˆçº§)

---

### 4.3 ã€ä¸­ã€‘WebSocketç¼ºå°‘è®¤è¯

**ä½ç½®:** `go-backend/cmd/server/main.go:159-178`

**é—®é¢˜ä»£ç :**

```go
router.GET("/ws", func(c *gin.Context) {
    // âŒ æœªéªŒè¯ç”¨æˆ·èº«ä»½
    // ä»»ä½•äººéƒ½å¯ä»¥è¿æ¥WebSocket
    handleWebSocket(c, hub)
})
```

**é£é™©ç­‰çº§:** ğŸŸ¡ **ä¸­** (Medium)

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
// âœ… æ·»åŠ JWTéªŒè¯
router.GET("/ws", middleware.AuthMiddleware(jwtSecret), func(c *gin.Context) {
    // ä»contextè·å–ç”¨æˆ·ID
    userID, _ := c.Get("user_id")

    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        return
    }

    client := &websocket.Client{
        ID:     uuid.New().String(),
        UserID: userID.(uint),  // âœ… ç»‘å®šç”¨æˆ·
        Conn:   conn,
        // ...
    }

    hub.register <- client
    go client.WritePump()
    go client.ReadPump()
})
```

**å®æ–½æˆæœ¬:** ä½ (1-2å°æ—¶)
**ä¼˜å…ˆçº§:** P2 (ä¸­ä¼˜å…ˆçº§)

---

## 5. æ€§èƒ½ç“¶é¢ˆ

### 5.1 ã€é«˜ã€‘æ•°æ®åº“N+1æŸ¥è¯¢é—®é¢˜

**ä½ç½®:** å¤šä¸ªæœåŠ¡å±‚

**é—®é¢˜ç¤ºä¾‹:**

```go
// âŒ N+1æŸ¥è¯¢é—®é¢˜
func (s *GridTradingService) GetUserGridStrategies(...) ([]GridStrategy, error) {
    var strategies []GridStrategy
    db.Where("user_id = ?", userID).Find(&strategies)

    // éå†æŸ¥è¯¢ç½‘æ ¼å±‚çº§ â†’ Næ¬¡æŸ¥è¯¢!
    for i := range strategies {
        var levels []GridLevel
        db.Where("strategy_id = ?", strategies[i].ID).Find(&levels)
        strategies[i].Levels = levels
    }

    return strategies, nil
}
```

**æ€§èƒ½å½±å“:**

```
100ä¸ªç­–ç•¥ â†’ 1 + 100 = 101æ¬¡æ•°æ®åº“æŸ¥è¯¢
æ¯æ¬¡æŸ¥è¯¢ 10ms â†’ æ€»è€—æ—¶ 1010ms
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
// âœ… ä½¿ç”¨Preloadé¢„åŠ è½½
func (s *GridTradingService) GetUserGridStrategies(...) ([]GridStrategy, error) {
    var strategies []GridStrategy

    // ä¸€æ¬¡æŸ¥è¯¢åŠ è½½æ‰€æœ‰å…³è”æ•°æ®
    err := db.Where("user_id = ?", userID).
        Preload("Levels").  // âœ… é¢„åŠ è½½ç½‘æ ¼å±‚çº§
        Find(&strategies).Error

    return strategies, err
}

// å®šä¹‰æ¨¡å‹å…³è”
type GridStrategy struct {
    // ...
    Levels []GridLevel `gorm:"foreignKey:StrategyID"`
}
```

**æ€§èƒ½æå‡:**

```
ä¼˜åŒ–å‰: 101æ¬¡æŸ¥è¯¢, 1010ms
ä¼˜åŒ–å: 2æ¬¡æŸ¥è¯¢, 20ms
æ€§èƒ½æå‡: 50å€
```

**å®æ–½æˆæœ¬:** ä½ (2-3å°æ—¶å®¡æŸ¥)
**ä¼˜å…ˆçº§:** P1 (é«˜ä¼˜å…ˆçº§)

---

### 5.2 ã€ä¸­ã€‘ç¼ºå°‘Redisç¼“å­˜

**é—®é¢˜æè¿°:**

```
é«˜é¢‘æŸ¥è¯¢åœºæ™¯:
â”œâ”€â”€ è®¢å•ç°¿æ·±åº¦ (æ¯ç§’1000+è¯·æ±‚)
â”œâ”€â”€ æœ€æ–°æˆäº¤ä»· (æ¯ç§’500+è¯·æ±‚)
â””â”€â”€ ç”¨æˆ·ä½™é¢ (æ¯ç§’300+è¯·æ±‚)

â†’ æ‰€æœ‰è¯·æ±‚ç›´æ¥æ‰“åˆ°æ•°æ®åº“
â†’ æ•°æ®åº“å‹åŠ›å¤§, å“åº”æ…¢
```

**æ”¹è¿›æ–¹æ¡ˆ:**

```go
import "github.com/redis/go-redis/v9"

type MarketHandler struct {
    orderService *OrderService
    redis        *redis.Client
}

func (h *MarketHandler) GetDepth(c *gin.Context) {
    symbol := c.Param("symbol")

    // [1] âœ… å…ˆæŸ¥Redisç¼“å­˜
    cacheKey := fmt.Sprintf("depth:%s", symbol)
    cachedDepth, err := h.redis.Get(c, cacheKey).Result()

    if err == nil {
        // ç¼“å­˜å‘½ä¸­
        c.Data(200, "application/json", []byte(cachedDepth))
        return
    }

    // [2] ç¼“å­˜æœªå‘½ä¸­, æŸ¥æ•°æ®åº“
    bids, asks := h.orderService.GetOrderBookDepth(symbol, 20)

    depth := gin.H{
        "bids": bids,
        "asks": asks,
    }

    depthJSON, _ := json.Marshal(depth)

    // [3] âœ… å†™å…¥ç¼“å­˜ (1ç§’è¿‡æœŸ)
    h.redis.Set(c, cacheKey, depthJSON, time.Second)

    c.JSON(200, depth)
}
```

**æ€§èƒ½æå‡:**

```
ç¼“å­˜å‘½ä¸­ç‡: 90%
å¹³å‡å“åº”æ—¶é—´:
- ç¼“å­˜å‘½ä¸­: 1ms (Redis)
- ç¼“å­˜æœªå‘½ä¸­: 20ms (PostgreSQL)
- å¹³å‡: 0.9Ã—1 + 0.1Ã—20 = 2.9ms

ç›¸æ¯”æ— ç¼“å­˜ (20ms), æ€§èƒ½æå‡7å€
```

**å®æ–½æˆæœ¬:** ä¸­ (6-8å°æ—¶)
**ä¼˜å…ˆçº§:** P1 (é«˜ä¼˜å…ˆçº§)

---

## 6. æ”¹è¿›ä¼˜å…ˆçº§ä¸è·¯çº¿å›¾

### 6.1 ç«‹å³ä¿®å¤ (P0) - 1-2å‘¨

| ç¼ºé™· | å½±å“ | å·¥æ—¶ |
|------|------|------|
| æ™ºèƒ½åˆçº¦ç¼ºå°‘æš‚åœæœºåˆ¶ | èµ„é‡‘å®‰å…¨ | 2å°æ—¶ |
| è®¢å•ç°¿æ€§èƒ½ç“¶é¢ˆ | ç³»ç»Ÿå¯ç”¨æ€§ | 12å°æ—¶ |
| æ æ†äº¤æ˜“ç¼ºå°‘èµ„äº§é”å®š | èµ„é‡‘å®‰å…¨ | 6å°æ—¶ |
| JWTå¯†é’¥ç¡¬ç¼–ç  | è´¦æˆ·å®‰å…¨ | 2å°æ—¶ |

**æ€»å·¥æ—¶:** 22å°æ—¶ (~3ä¸ªå·¥ä½œæ—¥)

---

### 6.2 é«˜ä¼˜å…ˆçº§ (P1) - 3-4å‘¨

| ç¼ºé™· | å½±å“ | å·¥æ—¶ |
|------|------|------|
| DEXç™½åå•ç¼ºä¹éªŒè¯ | åˆçº¦å®‰å…¨ | 1å°æ—¶ |
| ç¼ºå°‘ä»·æ ¼é¢„è¨€æœºä¿æŠ¤ | é˜²é—ªç”µè´·æ”»å‡» | 6å°æ—¶ |
| æ’®åˆå¼•æ“ç¼ºå°‘äº‹åŠ¡ä¿è¯ | æ•°æ®ä¸€è‡´æ€§ | 10å°æ—¶ |
| SQLæ³¨å…¥é£é™©å®¡æŸ¥ | æ•°æ®å®‰å…¨ | 3å°æ—¶ |
| æ•°æ®åº“N+1æŸ¥è¯¢ä¼˜åŒ– | æ€§èƒ½ | 3å°æ—¶ |
| Redisç¼“å­˜é›†æˆ | æ€§èƒ½ | 8å°æ—¶ |
| æœåŠ¡é™çº§æœºåˆ¶ | å¯ç”¨æ€§ | 8å°æ—¶ |

**æ€»å·¥æ—¶:** 39å°æ—¶ (~5ä¸ªå·¥ä½œæ—¥)

---

### 6.3 ä¸­ä¼˜å…ˆçº§ (P2) - 1-2ä¸ªæœˆ

| æ”¹è¿›é¡¹ | æ”¶ç›Š | å·¥æ—¶ |
|--------|------|------|
| å¤šç­¾é’±åŒ…ä¿æŠ¤ | å®‰å…¨ | 2å°æ—¶ |
| å¥–åŠ±ä¸Šé™é™åˆ¶ | å®‰å…¨ | 0.5å°æ—¶ |
| ç½‘æ ¼äº¤æ˜“å¹¶å‘ä¼˜åŒ– | æ€§èƒ½ | 3å°æ—¶ |
| åˆ†å¸ƒå¼é“¾è·¯è¿½è¸ª | å¯è§‚æµ‹æ€§ | 10å°æ—¶ |
| æ¶ˆæ¯é˜Ÿåˆ—å¯é æ€§ | æ•°æ®å¯é æ€§ | 6å°æ—¶ |
| WebSocketè®¤è¯ | å®‰å…¨ | 2å°æ—¶ |

**æ€»å·¥æ—¶:** 23.5å°æ—¶ (~3ä¸ªå·¥ä½œæ—¥)

---

### 6.4 æ€»ä½“æ—¶é—´çº¿

```
Week 1-2:  P0ç¼ºé™·ä¿®å¤ (ç«‹å³ä¿®å¤)
Week 3-6:  P1ç¼ºé™·ä¿®å¤ + æ€§èƒ½ä¼˜åŒ–
Week 7-12: P2æ”¹è¿›é¡¹ + æ–°åŠŸèƒ½å¼€å‘

å¹¶è¡Œè¿›è¡Œ:
â”œâ”€â”€ ä»£ç å®¡è®¡ (æŒç»­)
â”œâ”€â”€ æµ‹è¯•è¡¥å…… (ç›®æ ‡è¦†ç›–ç‡80%)
â””â”€â”€ æ–‡æ¡£å®Œå–„
```

---

## 7. è´¨é‡ä¿éšœå»ºè®®

### 7.1 æµ‹è¯•ç­–ç•¥

```
æµ‹è¯•é‡‘å­—å¡”:
â”œâ”€â”€ å•å…ƒæµ‹è¯• (Unit Tests) - ç›®æ ‡70%è¦†ç›–ç‡
â”‚   â”œâ”€â”€ æ’®åˆå¼•æ“é€»è¾‘æµ‹è¯•
â”‚   â”œâ”€â”€ é£æ§è§„åˆ™æµ‹è¯•
â”‚   â””â”€â”€ æ æ†äº¤æ˜“è®¡ç®—æµ‹è¯•
â”‚
â”œâ”€â”€ é›†æˆæµ‹è¯• (Integration Tests) - ç›®æ ‡50%è¦†ç›–ç‡
â”‚   â”œâ”€â”€ APIç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ æ•°æ®åº“äº‹åŠ¡æµ‹è¯•
â”‚   â””â”€â”€ WebSocketé€šä¿¡æµ‹è¯•
â”‚
â”œâ”€â”€ åˆçº¦æµ‹è¯• (Contract Tests)
â”‚   â”œâ”€â”€ Hardhatå•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ Foundryæ¨¡ç³Šæµ‹è¯•
â”‚   â””â”€â”€ GasåŸºå‡†æµ‹è¯•
â”‚
â””â”€â”€ å‹åŠ›æµ‹è¯• (Load Tests)
    â”œâ”€â”€ 1000 TPSè®¢å•å¤„ç†
    â”œâ”€â”€ 10000å¹¶å‘WebSocketè¿æ¥
    â””â”€â”€ æ’®åˆå¼•æ“æ€§èƒ½åŸºå‡†
```

### 7.2 ä»£ç å®¡æŸ¥æµç¨‹

```
Pull Requestæµç¨‹:
â”œâ”€â”€ [1] è‡ªåŠ¨åŒ–æ£€æŸ¥
â”‚   â”œâ”€â”€ CI/CDç®¡é“è¿è¡Œ
â”‚   â”œâ”€â”€ å•å…ƒæµ‹è¯•é€šè¿‡
â”‚   â”œâ”€â”€ ä»£ç è¦†ç›–ç‡â‰¥70%
â”‚   â”œâ”€â”€ Lintæ£€æŸ¥é€šè¿‡
â”‚   â””â”€â”€ å®‰å…¨æ‰«æé€šè¿‡ (Slither, gosec)
â”‚
â”œâ”€â”€ [2] äººå·¥å®¡æŸ¥
â”‚   â”œâ”€â”€ è‡³å°‘2åå®¡æŸ¥è€…æ‰¹å‡†
â”‚   â”œâ”€â”€ æ¶æ„å¸ˆå®¡æŸ¥ (é‡å¤§å˜æ›´)
â”‚   â””â”€â”€ å®‰å…¨ä¸“å®¶å®¡æŸ¥ (å®‰å…¨ç›¸å…³)
â”‚
â””â”€â”€ [3] åˆå¹¶å
    â”œâ”€â”€ éƒ¨ç½²åˆ°Stagingç¯å¢ƒ
    â”œâ”€â”€ å›å½’æµ‹è¯•
    â””â”€â”€ ç°åº¦å‘å¸ƒåˆ°ç”Ÿäº§
```

### 7.3 ç›‘æ§å‘Šè­¦

```
å…³é”®æŒ‡æ ‡ç›‘æ§:
â”œâ”€â”€ ä¸šåŠ¡æŒ‡æ ‡
â”‚   â”œâ”€â”€ è®¢å•å¤„ç†å»¶è¿Ÿ (p50, p95, p99)
â”‚   â”œâ”€â”€ æ’®åˆæˆåŠŸç‡
â”‚   â”œâ”€â”€ APIé”™è¯¯ç‡
â”‚   â””â”€â”€ WebSocketè¿æ¥æ•°
â”‚
â”œâ”€â”€ ç³»ç»ŸæŒ‡æ ‡
â”‚   â”œâ”€â”€ CPUä½¿ç”¨ç‡ (>80%å‘Šè­¦)
â”‚   â”œâ”€â”€ å†…å­˜ä½¿ç”¨ç‡ (>85%å‘Šè­¦)
â”‚   â”œâ”€â”€ æ•°æ®åº“è¿æ¥æ±  (>90%å‘Šè­¦)
â”‚   â””â”€â”€ Goroutineæ³„æ¼æ£€æµ‹
â”‚
â””â”€â”€ å®‰å…¨æŒ‡æ ‡
    â”œâ”€â”€ ç™»å½•å¤±è´¥ç‡ (å¼‚å¸¸å‘Šè­¦)
    â”œâ”€â”€ å¼‚å¸¸å¤§é¢è®¢å•
    â”œâ”€â”€ é£æ§è§„åˆ™è§¦å‘æ¬¡æ•°
    â””â”€â”€ åˆçº¦äº¤æ˜“å¼‚å¸¸
```

---

## 8. æ€»ç»“

### 8.1 æ ¸å¿ƒé—®é¢˜æ±‡æ€»

**ä¸¥é‡é—®é¢˜ (P0):**
1. âœ… æ™ºèƒ½åˆçº¦ç¼ºå°‘æš‚åœæœºåˆ¶ â†’ æ·»åŠ  Pausable
2. âœ… è®¢å•ç°¿O(n)æ€§èƒ½ç“¶é¢ˆ â†’ ä½¿ç”¨å †/çº¢é»‘æ ‘
3. âœ… æ æ†äº¤æ˜“èµ„äº§æœªé”å®š â†’ æ·»åŠ äº‹åŠ¡ä¿è¯
4. âœ… JWTå¯†é’¥ç¡¬ç¼–ç  â†’ ä½¿ç”¨ç¯å¢ƒå˜é‡

**é«˜ä¼˜å…ˆçº§é—®é¢˜ (P1):**
5. âœ… ä»·æ ¼é¢„è¨€æœºç¼ºå¤± â†’ é›†æˆChainlink
6. âœ… æ’®åˆå¼•æ“æ— äº‹åŠ¡ â†’ æ·»åŠ GORMäº‹åŠ¡
7. âœ… N+1æŸ¥è¯¢é—®é¢˜ â†’ ä½¿ç”¨Preload
8. âœ… ç¼ºå°‘Redisç¼“å­˜ â†’ é›†æˆç¼“å­˜å±‚

### 8.2 å­¦ä¹ è¦ç‚¹

é€šè¿‡æœ¬é¡¹ç›®ç¼ºé™·åˆ†æ,å¼€å‘è€…åº”æŒæ¡:

1. **æ™ºèƒ½åˆçº¦å®‰å…¨**: Pausable, é¢„è¨€æœº, å¤šç­¾é’±åŒ…
2. **é«˜æ€§èƒ½ç³»ç»Ÿè®¾è®¡**: æ•°æ®ç»“æ„é€‰æ‹©, ç¼“å­˜ç­–ç•¥
3. **å¹¶å‘å®‰å…¨**: é”ç­–ç•¥, äº‹åŠ¡ä¿è¯, æ•°æ®ä¸€è‡´æ€§
4. **é‡‘èç³»ç»Ÿé£æ§**: èµ„äº§é”å®š, é£é™©è¯„åˆ†, é™æµ

### 8.3 æŒç»­æ”¹è¿›å»ºè®®

```
å­£åº¦æ”¹è¿›è®¡åˆ’:
â”œâ”€â”€ Q1: ä¿®å¤P0å’ŒP1ç¼ºé™·
â”œâ”€â”€ Q2: æ€§èƒ½ä¼˜åŒ– + æµ‹è¯•è¦†ç›–ç‡æå‡
â”œâ”€â”€ Q3: ç›‘æ§å‘Šè­¦å®Œå–„ + ç¾å¤‡æ¼”ç»ƒ
â””â”€â”€ Q4: æ¶æ„é‡æ„ + å¾®æœåŠ¡æ‹†åˆ†
```

---

**æ–‡æ¡£ç‰ˆæœ¬:** v1.0
**æœ€åæ›´æ–°:** 2025-11-02
**ä½œè€…**: Aitachi (44158892@qq.com)

**ç›¸å…³æ–‡æ¡£:**
- [æ™ºèƒ½åˆçº¦å®‰å…¨å®¡è®¡](./smart-contract-audit.md)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](./performance-optimization.md)
- [è¿ç»´æ‰‹å†Œ](./operations-guide.md)
